# Расширение типов узлов

Типы узлов суть операционные инструкции, разные инструкции представляют различные действия в процессе.

Как и триггеры, расширение типов узлов также включает две части: серверную и клиентскую. На сервере необходимо реализовать логику для зарегистрированных инструкций, а на клиенте — предоставить интерфейсную конфигурацию параметров узла, где будут находиться инструкции.

## Серверная часть

### Самая простая инструкция узла

Основной содержимой частью инструкции является функция, то есть метод `run` в классе инструкции должен быть обязательно реализован, чтобы выполнять логику инструкции. Внутри функции можно выполнять любые необходимые операции, такие как работа с базой данных, файлами, вызов внешних API и т.д.

Все инструкции должны наследоваться от базового класса `Instruction`. Самая простая инструкция требует реализации только одного метода `run`:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class MyInstruction extends Instruction {
  run(node, input, processor) {
    console.log('my instruction runs!');
    return {
      status: JOB_STATUS.RESOVLED,
    };
  }
}
```

Чтобы зарегистрировать эту инструкцию в плагине рабочих процессов:

```ts
export default class MyPlugin extends Plugin {
  load() {
    // get workflow plugin instance
    const workflowPlugin = this.app.getPlugin<WorkflowPlugin>(WorkflowPlugin);

    // register instruction
    workflowPlugin.registerInstruction('my-instruction', MyInstruction);
  }
}
```

Статусное значение (`status`) возвращаемого объекта инструкции является обязательным и должно быть одним из значений констант `JOB_STATUS`. Это значение определяет流向后续处理的流向 для данного узла в рабочем процессе. Обычно можно использовать `JOB_STATUS.RESOLVED`, что означает успешное выполнение узла, и дальнейшее продолжение выполнения последующих узлов. Если необходимо сохранить результат выполнения заранее, можно использовать метод `processor.saveJob` и вернуть объект, возвращаемый этим методом. Экзекьютор сгенерирует запись выполнения на основе этого объекта.

### Результаты узла

Если у узла есть определенные результаты выполнения, особенно если они готовы для использования последующими узлами, их можно вернуть через атрибут `result` и сохранить в объекте задачи узла:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class RandomStringInstruction extends Instruction {
  run(node, input, processor) {
    // customized config from node
    const { digit = 1 } = node.config;
    const result = `${Math.round(10 ** digit * Math.random())}`.padStart(
      digit,
      '0',
    );
    return {
      status: JOB_STATUS.RESOVLED,
      result,
    };
  },
};
```

Где `node.config` — это конфигурация узла и может содержать любые необходимые значения. Эти значения будут сохранены в соответствующей записи узла в базе данных в виде поля типа `JSON`.

### Обработка ошибок в инструкции

Если в процессе выполнения могут возникнуть исключения, их можно предварительно перехватить и вернуть состояние ошибки:

```ts
import { JOB_STATUS } from '@nocobase/plugin-workflow';

export const errorInstruction = {
  run(node, input, processor) {
    try {
      throw new Error('exception');
    } catch (error) {
      return {
        status: JOB_STATUS.ERROR,
        result: error,
      };
    }
  },
};
```

Если не перехватывать предсказуемые исключения, движок рабочих процессов автоматически перехватит их и вернет состояние ошибки, чтобы избежать падения программы из-за непойманных исключений.

### Асинхронные узлы

При необходимости контролировать поток или выполнять асинхронные (долгие) операции ввода-вывода метод `run` может вернуть объект со статусом `JOB_STATUS.PENDING`, что указывает выполнителю на ожидание (приостановку), пока не завершатся некоторые внешние асинхронные операции. После завершения этих операций можно уведомить движок рабочих процессов продолжить выполнение. Если в методе `run` возвращается статус приостановки, инструкция должна реализовать метод `resume`, иначе восстановление выполнения процесса станет невозможным:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class PayInstruction extends Instruction {
  async run(node, input, processor) {
    // job could be create first via processor
    const job = await processor.saveJob({
      status: JOB_STATUS.PENDING,
    });

    const { plugin } = processor;
    // do payment asynchronously
    paymentService.pay(node.config, (result) => {
      // notify processor to resume the job
      return plugin.resume(job.id, result);
    });

    // return created job instance
    return job;
  }

  resume(node, job, processor) {
    // check payment status
    job.set('status', job.result.status === 'ok' ? JOB_STATUS.RESOVLED : JOB_STATUS.REJECTED);
    return job;
  },
};
```

Где `paymentService` указывает на некоторый платежный сервис. В callback-функции этого сервиса можно вызвать восстановление рабочего процесса для продолжения выполнения соответствующей задачи. Текущий процесс временно завершается, а затем движок рабочих процессов создает новый процессор и передает его методу `resume` узла, чтобы продолжить выполнение ранее приостановленного узла.

:::info{title=Подсказка}
Здесь упоминаемые «асинхронные операции» не относятся к асинхронным функциям в JavaScript, а означают взаимодействие с внешними системами, где некоторые операции не возвращают результат сразу, например, платежный сервис может потребовать ожидания дополнительного уведомления, чтобы узнать результат.

:::

### Состояние выполнения узла

Состояние выполнения узла влияет на успех или неудачу всего процесса. Обычно, в случае отсутствия ветвлений, неудача одного узла приводит к неудаче всего процесса. В обычной ситуации, если выполнение узла завершилось успешно, процесс переходит к следующему узлу в списке узлов, и процесс считается успешно завершен, если больше нет следующих узлов.

Если в процессе выполнения какой-либо узел возвращает состояние неудачи, движок рабочих процессов обрабатывает это следующим образом:

1. Если узел, возвращающий состояние неудачи, находится в основном потоке, то есть не находится внутри ветвления, запущенного каким-либо предыдущим узлом, то весь основной поток считается неудачным, и процесс завершается.

2. Если узел, возвращающий состояние неудачи, находится внутри какого-либо ветвления, то ответственность за определение следующего состояния процесса передается узлу, открывшему ветвление. Этот узел определяет дальнейшее состояние процесса в соответствии с внутренней логикой, и эта логика рекурсивно распространяется до основного потока.

В конечном итоге состояние следующего шага процесса определяется на узлах основного потока. Если узел основного потока возвращает состояние неудачи, то весь процесс завершается с состоянием неудачи.

Если какой-либо узел возвращает состояние «ожидания», то весь процесс выполнения временно приостанавливается и приостанавливается, ожидая триггера события, определенного соответствующим узлом, чтобы возобновить выполнение процесса. Например, в [ручном узле](../manual/nodes/manual), при выполнении до этого узла процесс приостанавливается с состоянием «ожидания», ожидая вмешательства человека в процесс для принятия решения о прохождении. Если человек выбирает прохождение, процесс продолжается с следующего узла, в противном случае применяются логика обработки неудачи.

Дополнительные состояния возврата инструкций можно найти в разделе [Справочник API рабочих процессов](./api#JOB_STATUS).

### Ранний выход

В некоторых специальных процессах может потребоваться завершить процесс прямо из какого-либо узла, возвращая `null`, что означает выход из текущего процесса и прекращение выполнения последующих узлов.

Такая ситуация часто встречается в узлах управления процессами, например, в [узле параллельных ветвей](../manual/nodes/parallel) (см. [код](https://github.com/nocobase/nocobase/blob/main/packages/plugins/%40nocobase/plugin-workflow-parallel/src/server/ParallelInstruction.ts#L87)), где текущий процесс узла завершается, но для каждой подветви создается новый процесс, который продолжает выполняться.

:::warn{title=Подсказка}
Расширение узлов для управления ветвями имеет определенную сложность и требует осторожного подхода с проведением достаточного тестирования.
:::

### Узнать больше

Определение параметров различных типов узлов см. в разделе [Справочник API рабочих процессов](.api#instruction).

## Клиентская часть

Как и триггеры, конфигурационная форма для инструкций (узлов) должна быть реализована на клиентской стороне.

### Самая простая инструкция узла

Все инструкции должны наследоваться от базового класса `Instruction`, а их свойства и методы используются для конфигурации и использования узлов.

Например, если нам нужно предоставить интерфейс конфигурации для узла типа случайной строки (`randomString`), определенного на серверной стороне, и у него есть конфигурационный параметр `digit`, представляющий количество цифр в случайной строке, в форме конфигурации мы можем использовать поле ввода числа для получения ввода пользователя.

```tsx | pure
import WorkflowPlugin, { Instruction, VariableOption } from '@nocobase/workflow/client';

class MyInstruction extends Instruction {
  title = 'Random number string';
  type = 'randomString';
  group = 'extended';
  fieldset = {
    'digit': {
      type: 'number',
      title: 'Digit',
      name: 'digit',
      'x-decorator': 'FormItem',
      'x-component': 'InputNumber',
      'x-component-props': {
        min: 1,
        max: 10,
      },
      default: 6,
    },
  };
  useVariables(node, options): VariableOption {
    return {
      value: node.key,
      label: node.title,
    };
  }
}

export default class MyPlugin extends Plugin {
  load() {
    // get workflow plugin instance
    const workflowPlugin = this.app.getPlugin<WorkflowPlugin>(WorkflowPlugin);

    // register instruction
    workflowPlugin.registerInstruction('log', LogInstruction);
  }
}
```

:::info{title=Подсказка}
Идентификатор типа узла, зарегистрированный на клиентской стороне, должен совпадать с идентификатором на серверной стороне, иначе это приведет к ошибкам.
:::

### Предоставление результатов узла в виде переменных

Обратите внимание на метод `useVariables` в приведенном выше примере. Если необходимо предоставить результаты узла (часть `result`) в виде переменных для использования в последующих узлах, нужно реализовать этот метод в наследуемом классе инструкции и вернуть объект, соответствующий типу `VariableOption`. Этот объект служит структурным описанием результатов выполнения узла и предоставляет отображение переменных, которое может быть использовано для выбора в последующих узлах.

Тип `VariableOption` определен следующим образом:

```ts
export type VariableOption = {
  value?: string;
  label?: string;
  children?: VariableOption[] | null;
  [key: string]: any;
};
```

Ключевым является свойство `value`, которое представляет собой путь пути значений переменной, разделенный символом `.`. Свойство `label` используется для отображения на интерфейсе, а `children` используется для представления многоуровневой структуры переменных, когда результат узла является глубоким объектом.

Используемая переменная внутри системы выражается в виде шаблонной строки с разделителями `.`. Например, `{{jobsMapByNodeKey.2dw92cdf.abc}}`. Здесь `$jobsMapByNodeKey` представляет собой набор результатов всех узлов (внутренне определен и не требует обработки), `2dw92cdf` — это ключ узла, а `abc` — это некоторое пользовательское свойство в объекте результата узла.

Кроме того, поскольку результат узла может быть и простым значением, при предоставлении переменных узла первым уровнем **обязательно** должен быть сам узел.

```ts
{
  value: node.key,
  label: node.title,
}
```

То есть первый уровень должен включать ключ узла и его заголовок. Например, для узла вычисления, как показано в [коде](https://github.com/nocobase/nocobase/blob/main/packages/plugins/%40nocobase/plugin-workflow/src/client/nodes/calculation.tsx#L77), при использовании результата узла вычисления, интерфейсные опции будут следующими:

![Результаты узла вычисления](https://static-docs.nocobase.com/20240514230014.png)

Когда результат узла является сложным объектом, можно использовать `children` для описания глубоких свойств. Например, пользовательский узел может вернуть следующие JSON-данные:

```json
{
  "message": "ok",
  "data": {
    "id": 1,
    "name": "test",
  }
}
```

То можно использовать следующий метод `useVariables` для возврата:

```ts
useVariables(node, options): VariableOption {
  return {
    value: node.key,
    label: node.title,
    children: [
      {
        value: 'message',
        label: 'Message',
      },
      {
        value: 'data',
        label: 'Data',
        children: [
          {
            value: 'id',
            label: 'ID',
          },
          {
            value: 'name',
            label: 'Name',
          },
        ],
      },
    ],
  };
}
```

Таким образом, в последующих узлах можно использовать следующий интерфейс для выбора переменных:

![Отображаемые результаты переменных](https://static-docs.nocobase.com/20240514230103.png)

:::info{title="Подсказка"}
Когда структура результата является массивом глубоких объектов, можно использовать `children` для описания пути, но нельзя включать индексы массива, так как в обработке переменных в рабочих процессах NocoBase пути для массивов объектов автоматически преобразуются в плоские массивы значений и не поддерживают доступ по индексу. Подробнее можно прочитать в разделе [Рабочие процессы: продвинутое использование](../manual/advanced#использование-переменных).
:::

### Узнать больше

Определение параметров различных типов узлов см. в разделе [Справочник API рабочих процессов](./api#instruction-1).
