# Таблицы и поля

## Базовые концепции

Моделирование данных является самой базовой основой приложения. В приложении NocoBase мы используем таблицы (Collection) и поля (Field) для моделирования данных, и эти данные также будут отображаться в таблицах базы данных для обеспечения их постоянства.

### Collection

Collection — это набор всех однотипных данных. В NocoBase он соответствует концепции таблицы базы данных. Например, заказы, товары, пользователи, комментарии и т.д. могут быть определены как Collection. Различные Collection различаются по имени (name), а содержащиеся поля определяются через `fields`, например:

```ts
db.collection({
  name: 'posts',
  fields: [
    { name: 'title', type: 'string' },
    { name: 'content', type: 'text' },
    // ...
  ],
});
```

После завершения определения collection он временно находится только в памяти. Чтобы синхронизировать его с базой данных, необходимо вызвать метод [`db.sync()`](/api/database#sync).

### Field

Понятие, соответствующее "полю" таблицы базы данных. Каждая таблица данных (Collection) может иметь несколько Fields, например:

```ts
db.collection({
  name: 'users',
  fields: [
    { type: 'string', name: 'name' },
    { type: 'integer', name: 'age' },
    // 其他字段
  ],
});
```

При этом имя поля (`name`) и тип поля (`type`) являются обязательными для заполнения. Различные поля различаются по имени поля (`name`). Помимо `name` и `type`, в зависимости от типа поля могут быть доступны дополнительные параметры конфигурации. Все типы полей базы данных и их настройки подробно описаны в [списке встроенных типов полей](/api/database/field#内置字段类型列表) в справочнике API.

## Примеры

Для разработчиков обычно требуется создавать функциональные таблицы, которые отличаются от обычных таблиц данных. Эти таблицы закрепляются как часть плагина и интегрируются в другие процессы обработки данных для формирования полной функциональности.

Далее мы рассмотрим пример простого плагина интернет-магазина, чтобы показать, как моделировать и управлять таблицами данных плагина. Предполагается, что вы уже ознакомились с разделом [Создание первого плагина](/development/your-first-plugin). Мы продолжим разработку на основе предыдущего кода плагина, только название плагина изменится с `hello` на `shop-modeling`.

### Определение и создание таблиц данных в плагине

Для магазина необходимо сначала создать таблицу товаров, которую мы назовем `products`. В отличие от прямого вызова метода [`db.collection()`](/api/database#collection), в плагине мы будем использовать более удобный способ импорта определений нескольких таблиц из файлов. Поэтому сначала создадим файл для определения таблицы товаров, который назовем `collections/products.ts`, и добавим в него следующее содержимое:

```ts
export default {
  name: 'products',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
    {
      type: 'integer',
      name: 'price',
    },
    {
      type: 'boolean',
      name: 'enabled',
    },
    {
      type: 'integer',
      name: 'inventory',
    },
  ],
};
```

Как видно, структура таблицы данных в NocoBase может быть определена с использованием стандартного формата JSON, где `name` и `fields` являются обязательными полями, представляющими имя таблицы и определения полей этой таблицы. В определении полей, по аналогии с Sequelize, автоматически создаются системные поля, такие как первичный ключ (`id`), время создания данных (`createdAt`) и время обновления данных (`updatedAt`). При необходимости эти поля могут быть переопределены с помощью соответствующих настроек.

Таблица данных, определенная в этом файле, может быть импортирована и настроена в жизненном цикле `load()` основного класса плагина с помощью метода `db.import()`. Как показано ниже:

```ts
import path from 'path';
import { Plugin } from '@nocobase/server';

export default class ShopPlugin extends Plugin {
  async load() {
    await this.db.import({
      directory: path.resolve(__dirname, 'collections'),
    });

    this.app.acl.allow('products', '*');
    this.app.acl.allow('categories', '*');
    this.app.acl.allow('orders', '*');
  }
}
```

В целях удобства тестирования, мы временно разрешим все права доступа к данным в этих таблицах. Позже, в разделе [Управление правами](/development/guide/acl), мы подробно опишем, как управлять правами доступа к ресурсам.

Таким образом, при загрузке плагина основным приложением, наша определённая таблица `products` также будет загружена в память экземпляра управления базой данных. Одновременно с этим, благодаря соглашению NocoBase о сопоставлении ресурсов таблиц данных, после запуска службы приложения автоматически будут сгенерированы соответствующие CRUD HTTP API.

При обращении с клиента к следующему URL будут получены соответствующие результаты:

- `GET /api/products:list` — получить список всех товаров.
- `GET /api/products:get?filterByTk=<id>` — получить данные товара по указанному ID.
- `POST /api/products` — создать новую запись товара.
- `PUT /api/products:update?filterByTk=<id>` — обновить данные товара.
- `DELETE /api/products:destroy?filterByTk=<id>` — удалить запись товара.

### Определение таблиц отношений и полей связи

В приведённом выше примере мы определили только одну таблицу данных для товаров. Однако на практике товар также должен быть связан с категорией, брендом, поставщиком и т.д. Эти связи могут быть реализованы через определение таблиц связей. Например, можно определить таблицу `categories` для хранения категорий товаров, а затем добавить поле `category` в таблицу товаров для создания связи с таблицей категорий.

Создайте новый файл `collections/categories.ts` и добавьте в него следующее содержимое:

```ts
export default {
  name: 'categories',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
    {
      type: 'hasMany',
      name: 'products',
    },
  ],
};
```

Мы определили для таблицы `categories` два поля: одно для заголовка, а другое — поле "один-ко-многим" для всех связанных продуктов в этой категории, которое мы рассмотрим позже. Поскольку мы уже использовали метод `db.import()` в основном классе плагина для импорта всех определений таблиц из директории `collections`, новая таблица `categories` также будет автоматически импортирована в экземпляр управления базой данных.

Теперь отредактируем файл `collections/products.ts`, добавив поле `category` в раздел `fields`:

```ts
{
  name: 'products',
  fields: [
    // ...
    {
      type: 'belongsTo',
      name: 'category',
      target: 'categories',
    }
  ]
}
```

Как видно, для таблицы `products` мы добавили поле `category` типа `belongsTo`. Его свойство `target` указывает на таблицу `categories`, что определяет отношение "многие к одному" между таблицами `products` и `categories`. В сочетании с полем `hasMany`, которое мы определили в таблице `categories`, можно достичь связи, где один товар может быть связан с несколькими категориями, а одна категория может содержать множество товаров. Обычно поля `belongsTo` и `hasMany` используются парами, определяя отношения в обеих таблицах.

После того как связь между двумя таблицами определена, можно напрямую запрашивать связанные данные через HTTP API:

- `GET /api/products:list?appends=category` — получить все товары с данными о связанных категориях.
- `GET /api/products:get?filterByTk=<id>&appends=category` — получить данные товара по указанному ID с данными о связанных категориях.
- `GET /api/categories/<categoryId>/products:list` — получить все товары из указанной категории.
- `POST /api/categories/<categoryId>/products` — создать новый товар в указанной категории.

Подобно типичным ORM-фреймворкам, NocoBase предоставляет четыре встроенных типа полей отношений. Подробнее об этом можно узнать в соответствующем разделе документации API:

- [Тип `belongsTo`](/api/database/field#belongsto)
- [Тип `belongsToMany`](/api/database/field#belongstomany)
- [Тип `hasMany`](/api/database/field#hasmany)
- [Тип `hasOne`](/api/database/field#hasone)

### Расширение существующих таблиц данных

В приведённом выше примере у нас уже есть таблицы товаров и категорий. Для реализации процесса продаж нам также нужна таблица заказов. Мы можем добавить файл `orders.ts` в директорию `collections` и определить таблицу `orders`:

```ts
export default {
  name: 'orders',
  fields: [
    {
      type: 'uuid',
      name: 'id',
      primaryKey: true,
    },
    {
      type: 'belongsTo',
      name: 'product',
    },
    {
      type: 'integer',
      name: 'quantity',
    },
    {
      type: 'integer',
      name: 'totalPrice',
    },
    {
      type: 'integer',
      name: 'status',
    },
    {
      type: 'string',
      name: 'address',
    },
    {
      type: 'belongsTo',
      name: 'user',
    },
  ],
};
```

Для упрощения мы определили связь между заказами и товарами как отношение «многие к одному», хотя в реальных бизнес-сценариях могут использоваться более сложные модели, такие как «многие ко многим» или снимки данных. Как видно, помимо связи заказа с конкретным товаром, мы также добавили определение связи с пользователем. Пользователи управляются встроенными плагинами NocoBase (подробнее см. [код плагина пользователей](https://github.com/nocobase/nocobase/tree/main/packages/plugins/users)). Если мы хотим расширить существующую таблицу пользователей, добавив определение связи «один пользователь имеет несколько заказов», то в текущем плагине `shop-modeling` можно создать новый файл таблицы данных `collections/users.ts`. В отличие от прямого экспорта конфигурации таблицы данных в формате JSON, здесь используется метод `extend()` из пакета `@nocobase/database` для расширения уже существующей таблицы:

```ts
import { extend } from '@nocobase/database';

export extend({
  name: 'users',
  fields: [
    {
      type: 'hasMany',
      name: 'orders'
    }
  ]
});
```

Таким образом, в ранее существовавшей таблице пользователей появится поле связи `orders`, и мы сможем получить все заказы определённого пользователя с помощью запроса `GET /api/users/<userId>/orders:list`.

Этот метод очень полезен при расширении таблиц данных, определённых другими плагинами. Он позволяет избежать обратной зависимости новых плагинов от уже существующих, формируя только одностороннюю зависимость. Это упрощает декомпозицию на уровне расширений.

### Расширение типов полей

При определении таблицы заказов мы использовали для поля `id` встроенный тип `uuid`. Иногда UUID может казаться слишком длинным, занимая больше места, а также снижая производительность при выполнении запросов. В таких случаях можно захотеть использовать более подходящий тип поля, например, сложную логику нумерации с учётом даты или алгоритм Snowflake. Для этого потребуется расширить тип поля, создав собственный.

Предположим, что мы хотим применить алгоритм генерации Snowflake ID и создать новый тип поля `snowflake`. Для этого можно создать файл `fields/snowflake.ts`:

```ts
import { DataTypes } from 'sequelize';
// Импортируем библиотеку алгоритмов
import { Snowflake } from 'nodejs-snowflake';
// Импортируем базовый класс типов полей
import { Field, BaseColumnFieldOptions } from '@nocobase/database';

export interface SnowflakeFieldOptions extends BaseColumnFieldOptions {
  type: 'snowflake';
  epoch: number;
  instanceId: number;
}

export class SnowflakeField extends Field {
  get dataType() {
    return DataTypes.BIGINT;
  }

  constructor(options: SnowflakeFieldOptions, context) {
    super(options, context);

    const {
      epoch: custom_epoch,
      instanceId: instance_id = process.env.INSTANCE_ID
        ? Number.parseInt(process.env.INSTANCE_ID)
        : 0,
    } = options;
    this.generator = new Snowflake({ custom_epoch, instance_id });
  }

  setValue = (instance) => {
    const { name } = this.options;
    instance.set(name, this.generator.getUniqueID());
  };

  bind() {
    super.bind();
    this.on('beforeCreate', this.setValue);
  }

  unbind() {
    super.unbind();
    this.off('beforeCreate', this.setValue);
  }
}

export default SnowflakeField;
```

После этого в главном файле плагина нужно зарегистрировать новый тип поля в базе данных:

```ts
import SnowflakeField from './fields/snowflake';

export default class ShopPlugin extends Plugin {
  initialize() {
    // ...
    this.db.registerFieldTypes({
      snowflake: SnowflakeField,
    });
    // ...
  }
}
```

Теперь мы можем использовать тип поля `snowflake` в таблице заказов:

```ts
export default {
  name: 'orders',
  fields: [
    {
      type: 'snowflake'
      name: 'id',
      primaryKey: true
    },
    // ...другие поля
  ]
}
```

## Заключение

На основе приведённого выше примера мы в общих чертах разобрались, как выполнять моделирование данных в плагине, включая следующие аспекты:

- Определение таблиц данных и обычных полей
- Определение связанных таблиц и отношений между полями
- Расширение полей существующих таблиц данных
- Создание новых типов полей

Весь код, рассмотренный в этой главе, собран в отдельный пример пакета [packages/samples/shop-modeling](https://github.com/nocobase/nocobase/tree/main/packages/samples/shop-modeling), который можно запустить локально для просмотра результатов.
