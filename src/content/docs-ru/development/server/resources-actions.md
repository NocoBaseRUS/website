# Ресурсы и операции

В области веб-разработки вы могли слышать о концепции RESTful. NocoBase также использует понятие ресурсов, чтобы отображать различные сущности в системе, такие как данные в базе данных, файлы в файловой системе или определённые сервисы. Однако, исходя из практических соображений, NocoBase не следует полностью соглашениям RESTful, а расширяет их на основе рекомендаций из [Google Cloud API Design Guide](https://cloud.google.com/apis/design), чтобы адаптироваться к более широкому спектру сценариев.

## Базовые концепции

Подобно концепции ресурсов в RESTful, ресурсами являются объекты, предоставляемые системой для внешнего использования. Это могут быть таблицы данных, файлы и другие настраиваемые объекты.

Операции в основном относятся к чтению и записи данных ресурсов, обычно используемым для просмотра, создания, обновления и удаления данных. В NocoBase операции определяются через middleware-функции, совместимые с Koa, для обработки запросов к ресурсам.

### Автоматическое отображение таблиц данных в ресурсы

На данный момент основные ресурсы связаны с данными в таблицах. По умолчанию NocoBase автоматически отображает таблицы базы данных как ресурсы и предоставляет интерфейсы HTTP API для работы с ними. Таким образом, при использовании `db.collection()` для определения таблицы данных, эти данные будут доступны через HTTP API NocoBase. Имя сгенерированного ресурса будет соответствовать имени таблицы. Например, таблица, определённая как `db.collection({ name: 'users' })`, будет иметь соответствующий ресурс с именем `users`.

Кроме того, для этих ресурсов данных автоматически создаются стандартные операции CRUD. Для реляционных данных также предусмотрены методы для работы с отношениями.

Стандартные операции для простых ресурсов:

- [`list`](/api/actions#list): Получение списка данных из таблицы.
- [`get`](/api/actions#get): Получение одной записи данных из таблицы.
- [`create`](/api/actions#create): Создание новой записи в таблице.
- [`update`](/api/actions#update): Обновление одной записи в таблице.
- [`destroy`](/api/actions#destroy): Удаление одной записи из таблицы.

Для реляционных ресурсов, помимо стандартных операций CRUD, также доступны следующие операции для работы с отношениями:

- [`add`](/api/actions#add): Добавление связи к данным.
- [`remove`](/api/actions#remove): Удаление связи у данных.
- [`set`](/api/actions#set): Установка связи у данных.
- [`toggle`](/api/actions#toggle): Добавление или удаление связи у данных.

Например, определим таблицу данных для статей и синхронизируем её с базой данных:

```ts
app.db.collection({
  name: 'posts',
  fields: [{ type: 'string', name: 'title' }],
});

await app.db.sync();
```

После этого все методы CRUD для ресурса данных `posts` могут быть вызваны напрямую через HTTP API:

```bash
# create
curl -X POST -H "Content-Type: application/json" -d '{"title":"first"}' http://localhost:13000/api/posts:create
# list
curl http://localhost:13000/api/posts:list
# update
curl -X PUT -H "Content-Type: application/json" -d '{"title":"second"}' http://localhost:13000/api/posts:update
# destroy
curl -X DELETE http://localhost:13000/api/posts:destroy?filterByTk=1
```

### Пользовательские Action

В случаях, когда стандартные операции CRUD не удовлетворяют потребностям бизнес-сценариев, можно расширить функциональность конкретного ресурса дополнительными операциями. Например, это может быть дополнительная обработка встроенных операций или установка параметров по умолчанию.

Для определённого ресурса можно создать пользовательские операции, например, переопределить операцию `создания` в таблице статей:

```ts
// Эквивалентно app.resourcer.registerActions()
// Регистрация метода операции create для ресурса статей
app.actions({
  async ['posts:create'](ctx, next) {
    const postRepo = ctx.db.getRepository('posts');
    await postRepo.create({
      values: {
        ...ctx.action.params.values,
        // Ограничение: текущий пользователь должен быть автором статьи
        userId: ctx.state.currentUserId,
      },
    });

    await next();
  },
});
```

Таким образом, в бизнес-логике добавляется разумное ограничение: пользователи не могут создавать статьи от имени других пользователей.

Например, если нужно добавить операцию `экспорт` для всех таблиц данных:

```ts
app.actions({
  // Для всех ресурсов добавлен метод export, который используется для экспорта данных.
  async export(ctx, next) {
    const repo = ctx.db.getRepository(ctx.action.resource);
    const results = await repo.find({
      filter: ctx.action.params.filter,
    });
    ctx.type = 'text/csv';
    // Собираем данные в формат CSV
    ctx.body = results
      .map((row) =>
        Object.keys(row)
          .reduce((arr, col) => [...arr, row[col]], [])
          .join(','),
      )
      .join('\n');

    next();
  },
});
```

Затем данные можно экспортировать в формате CSV с помощью следующего HTTP API:

```bash
curl http://localhost:13000/api/<any_table>:export
```

### Параметры Action

После того как клиентский запрос достигает сервера, соответствующие параметры запроса анализируются согласно правилам и помещаются в объект `ctx.action.params` запроса. Параметры Action имеют три основных источника:

1. Параметры по умолчанию, заданные при определении Action.
2. Параметры, передаваемые клиентским запросом.
3. Параметры, обработанные другими middleware.

Перед тем как запрос достигнет функции обработки операции, параметры из этих трех источников объединяются в указанном порядке и передаются в исполняемую функцию операции. В случае нескольких middleware параметры, обработанные предыдущим middleware, продолжают передаваться через объект `ctx` в следующий middleware.

Для встроенных операций доступные параметры можно найти в документации пакета [@nocobase/actions](/api/actions). За исключением пользовательских операций, клиентские запросы в основном используют эти параметры. Для пользовательских операций параметры могут быть расширены в зависимости от потребностей бизнеса.

Middleware обычно используют метод `ctx.action.mergeParams()` для предварительной обработки параметров, причем стратегия слияния может различаться в зависимости от типа параметра. Подробнее о методе `mergeParams()` можно узнать [здесь](/api/resourcer/action#mergeparams).

При слиянии параметров по умолчанию для встроенных Action применяется метод `mergeParams()` с учетом различных стратегий для каждого параметра по умолчанию. Это позволяет на стороне сервера вводить ограничения на выполнение определенных операций. Например:

```ts
app.resource({
  name: 'posts',
  actions: {
    create: {
      whitelist: ['title', 'content'],
      blacklist: ['createdAt', 'createdById'],
    },
  },
});
```

Как показано выше, для операции `create` ресурса `posts` определены параметры `whitelist` и `blacklist`, которые представляют собой белый и черный списки для параметра `values`. То есть разрешается только наличие полей `title` и `content` в параметре `values`, а также запрещается использование полей `createdAt` и `createdById` в параметре `values`.

### Пользовательские ресурсы

Ресурсы, связанные с данными, делятся на независимые и связанные ресурсы:

- Независимый ресурс: `<collection>`
- Связанный ресурс: `<collection>.<association>`

```ts
// Эквивалентно app.resourcer.define()

// Определение ресурса статей
app.resource({
  name: 'posts',
});

// Определение ресурса авторов статей
app.resource({
  name: 'posts.user',
});

// Определение ресурса комментариев к статьям
app.resource({
  name: 'posts.coments',
});
```

Необходимость в пользовательской настройке возникает в основном для ресурсов, не связанных с таблицами базы данных, таких как данные в памяти или прокси-интерфейсы других сервисов, а также для случаев, когда требуется определить специфические операции для существующих ресурсов, связанных с таблицами.

Например, определим ресурс для операции отправки уведомлений, который не зависит от базы данных:

```ts
app.resource({
  name: 'notifications',
  actions: {
    async send(ctx, next) {
      await someProvider.send(ctx.request.body);
      next();
    },
  },
});
```

Тогда в HTTP API это можно использовать следующим образом:

```bash
curl -X POST -d '{"title": "Hello", "to": "hello@nocobase.com"}' 'http://localhost:13000/api/notifications:send'
```

## Пример

Продолжим рассматривать простой сценарий магазина из предыдущего [примера "Таблицы и поля"](https://nocobase.feishu.cn/wiki/Wv6vwII4Siw5GKkI322cYOiIn7g). Мы углубим понимание концепций, связанных с ресурсами и операциями. Здесь предполагается, что мы продолжаем работу на основе ранее определённых таблиц данных, поэтому повторное определение структуры таблиц не требуется.

Как только соответствующие таблицы данных определены, мы можем использовать стандартные операции для товаров, заказов и других ресурсов данных, чтобы выполнить базовые сценарии CRUD.

### Переопределение стандартных операций

Иногда работа идёт не только с отдельными записями или нужно контролировать параметры стандартных операций. В таких случаях можно переопределить стандартные операции. Например, при создании заказа клиент не должен иметь возможность отправлять `userId`, чтобы указать владельца заказа — это должно определяться на стороне сервера на основе текущего авторизованного пользователя. В этом случае мы можем переопределить стандартную операцию `create`. Для простого расширения мы можем напрямую добавить код в основной класс плагина:

```ts
import { Plugin } from '@nocobase/server';
import actions from '@nocobase/actions';

export default class ShopPlugin extends Plugin {
  async load() {
    // ...
    this.app.resource({
      name: 'orders',
      actions: {
        async create(ctx, next) {
          ctx.action.mergeParams({
            values: {
              userId: ctx.state.user.id,
            },
          });

          return actions.create(ctx, next);
        },
      },
    });
  }
}
```

Таким образом, в процессе загрузки плагина мы переопределили стандартную операцию `create` для ресурса данных заказов. Однако после изменения параметров операции мы всё равно вызвали стандартную логику, без необходимости писать её самостоятельно. Метод `mergeParams()`, который изменяет отправляемые параметры, очень полезен для встроенных операций по умолчанию — мы рассмотрим его позже.

### Пользовательские операции для ресурсов таблиц данных

Когда встроенные операции не удовлетворяют бизнес-требованиям, мы можем расширить функциональность ресурсов с помощью пользовательских операций. Например, у заказа может быть несколько состояний, и если мы определяем значения поля `status` как набор перечислений:

- `-1`: Отменён.
- `0`: Заказ создан, но не оплачен.
- `1`: Оплачен, но не отправлен.
- `2`: Отправлен, но не получен.
- `3`: Получен, заказ завершён.

Тогда мы могли бы реализовать изменение статуса заказа через пользовательские операции. Например, действие "отправка заказа" можно было бы выполнить с помощью операции `update`. Однако в более сложных случаях, таких как оплата или подтверждение получения, использование только `update` приведёт к неясной семантике и путанице в параметрах. Поэтому лучше использовать пользовательские операции.

Сначала добавим определение таблицы данных для информации о доставке и сохраним его в файл `collections/deliveries.ts`:

```ts
export default {
  name: 'deliveries',
  fields: [
    {
      type: 'belongsTo',
      name: 'order',
    },
    {
      type: 'string',
      name: 'provider',
    },
    {
      type: 'string',
      name: 'trackingNumber',
    },
    {
      type: 'integer',
      name: 'status',
    },
  ],
};
```

В то же время, мы расширим таблицу заказов полем связи с информацией о доставке (в файле `collections/orders.ts`):

```ts
export default {
  name: 'orders',
  fields: [
    // ...other fields
    {
      type: 'hasOne',
      name: 'delivery',
    },
  ],
};
```

Затем мы добавим соответствующее определение операции в основной класс плагина:

```ts
import { Plugin } from '@nocobase/server';

export default class ShopPlugin extends Plugin {
  async load() {
    // ...
    this.app.resource({
      name: 'orders',
      actions: {
        async deliver(ctx, next) {
          const { filterByTk } = ctx.action.params;
          const orderRepo = ctx.db.getRepository('orders');

          const [order] = await orderRepo.update({
            filterByTk,
            values: {
              status: 2,
              delivery: {
                ...ctx.action.params.values,
                status: 0,
              },
            },
          });

          ctx.body = order;

          next();
        },
      },
    });
  }
}
```

Здесь Repository — это класс хранилища данных таблицы, который отвечает за большинство операций чтения и записи данных. Подробнее можно узнать в разделе [Repository API](/api/database/repository).

После определения мы можем вызвать операцию "отправка" через HTTP API с клиента:

```bash
curl \
  -X POST \
  -H 'Content-Type: application/json' \
  -d '{"provider": "SF", "trackingNumber": "SF1234567890"}' \
  '/api/orders:deliver/<id>'
```

Таким же образом, мы можем определить больше подобных операций, таких как оплата или подтверждение получения.

### Объединение параметров

Предположим, мы хотим позволить пользователям запрашивать только свои собственные заказы и при этом ограничить возможность запроса отменённых заказов. В этом случае мы можем определить это через параметры по умолчанию для action:

```ts
import { Plugin } from '@nocobase/server';

export default class ShopPlugin extends Plugin {
  async load() {
    // ...
    this.app.resource({
      name: 'orders',
      actions: {
        // Параметры по умолчанию для операции list
        list: {
          filter: {
            // Оператор фильтрации, расширенный плагином users
            $isCurrentUser: true,
            status: {
              $ne: -1,
            },
          },
          fields: ['id', 'status', 'createdAt', 'updatedAt'],
        },
      },
    });
  }
}
```

Когда пользователь выполняет запрос с клиента, он также может добавить дополнительные параметры в URL запроса, например:

```bash
curl 'http://localhost:13000/api/orders:list?productId=1&fields=id,status,quantity,totalPrice&appends=product'
```

Фактические условия запроса будут объединены в:

```json
{
  "filter": {
    "$and": {
      "$isCurrentUser": true,
      "status": {
        "$ne": -1
      },
      "productId": 1
    }
  },
  "fields": [
    "id",
    "status",
    "quantity",
    "totalPrice",
    "createdAt",
    "updatedAt"
  ],
  "appends": ["product"]
}
```

И получить ожидаемый результат запроса.

Кроме того, если нам нужно ограничить возможность отправки клиентом таких полей, как номер заказа (`id`) или общей стоимости (`totalPrice`) через интерфейс создания заказа, мы можем наложить ограничения, определив параметры по умолчанию для операции `create`:

```ts
import { Plugin } from '@nocobase/server';

export default class ShopPlugin extends Plugin {
  async load() {
    // ...
    this.app.resource({
      name: 'orders',
      actions: {
        create: {
          blacklist: ['id', 'totalPrice', 'status', 'createdAt', 'updatedAt'],
          values: {
            status: 0,
          },
        },
      },
    });
  }
}
```

Таким образом, даже если клиент намеренно отправит эти поля, они будут отфильтрованы и не будут присутствовать в наборе параметров `ctx.action.params`.

Если требуется реализовать более сложные ограничения, например, разрешить оформление заказа только для товаров, которые находятся в наличии и выставлены на продажу, это можно сделать с помощью конфигурации middleware:

```ts
import { Plugin } from '@nocobase/server';

export default class ShopPlugin extends Plugin {
  async load() {
    // ...
    this.app.resource({
      name: 'orders',
      actions: {
        create: {
          middlewares: [
            async (ctx, next) => {
              const { productId } = ctx.action.params.values;

              const product = await ctx.db.getRepository('products').findOne({
                filterByTk: productId,
                filter: {
                  enabled: true,
                  inventory: {
                    $gt: 0,
                  },
                },
              });

              if (!product) {
                return ctx.throw(404);
              }

              await next();
            },
          ],
        },
      },
    });
  }
}
```

Вынесение части бизнес-логики (особенно предварительной обработки) в middleware делает код более понятным и упрощает его поддержку.

## Заключение

В приведённых выше примерах мы рассмотрели, как определять ресурсы и связанные с ними операции. Подведём итоги главы:

- Автоматическое отображение таблиц данных в ресурсы.
- Встроенные операции с ресурсами по умолчанию.
- Настройка пользовательских операций для ресурсов.
- Порядок и стратегия объединения параметров операций.

Код, связанный с этой главой, собран в отдельный пакет примеров [packages/samples/shop-actions](https://github.com/nocobase/nocobase/tree/main/packages/samples/shop-actions), который можно запустить локально для просмотра результатов.
