# Field

## Обзор

Класс управления полями таблицы данных (абстрактный класс). Также является базовым классом для всех типов полей, и любые другие типы полей реализуются путем наследования этого класса.

Как создавать пользовательские поля можно узнать в разделе [Расширение типов полей](/development/guide/collections-fields#расширение-типов-полей).

## Конструктор

Обычно разработчик напрямую не вызывает конструктор. Основной способ использования — через метод `db.collection({ fields: [] })`, который выступает в качестве прокси-входа.

При расширении полей основная задача заключается в наследовании абстрактного класса `Field` и последующей регистрации нового типа поля в экземпляре Database.

**Сигнатура**

- `constructor(options: FieldOptions, context: FieldContext)`

**Параметры**

| Параметр              | Тип            | Значение по умолчанию | Описание                                      |
| --------------------- | -------------- | --------------------- | --------------------------------------------- |
| `options`             | `FieldOptions` | -                     | Объект конфигурации поля                      |
| `options.name`        | `string`       | -                     | Имя поля                                      |
| `options.type`        | `string`       | -                     | Тип поля, соответствует имени типа поля в db   |
| `context`             | `FieldContext` | -                     | Объект контекста поля                         |
| `context.database`    | `Database`     | -                     | Экземпляр базы данных                         |
| `context.collection`  | `Collection`   | -                     | Экземпляр таблицы данных                       |

## Члены экземпляра

### `name`

Имя поля.

### `type`

Тип поля.

### `dataType`

Тип данных для хранения в базе данных.

### `options`

Параметры инициализации конфигурации поля.

### `context`

Объект контекста поля.

## Методы конфигурации

### `on()`

Удобный способ определения событий на основе событий таблицы данных. Аналогично вызову `db.on(this.collection.name + '.' + eventName, listener)`.

При наследовании обычно нет необходимости переопределять этот метод.

**Сигнатура**

- `on(eventName: string, listener: (...args: any[]) => void)`

**Параметры**

| Параметр    | Тип                       | Значение по умолчанию | Описание       |
| ----------- | -------------------------- | --------------------- | -------------- |
| `eventName` | `string`                   | -                     | Имя события    |
| `listener`  | `(...args: any[]) => void` | -                     | Обработчик события |

### `off()`

Способ быстрого удаления на основе событий таблицы данных. Аналогично `db.off(this.collection.name + '.' + eventName, listener)`.

При наследовании обычно не требуется переопределять этот метод.

**Сигнатура**

- `off(eventName: string, listener: (...args: any[]) => void)`

**Параметры**

| Имя параметра | Тип                       | Значение по умолчанию | Описание     |
| -------------- | -------------------------- | ---------------------- | ------------ |
| `eventName`    | `string`                   | -                      | Название события |
| `listener`     | `(...args: any[]) => void` | -                      | Обработчик события |

### `bind()`

Содержимое, выполняемое при добавлении поля в таблицу данных. Обычно используется для добавления обработчиков событий таблицы данных и другой обработки.

При наследовании необходимо сначала вызвать соответствующий метод `super.bind()`.

**Сигнатура**

- `bind()`

### `unbind()`

Содержимое, выполняемое при удалении поля из таблицы данных. Обычно используется для удаления обработчиков событий таблицы данных и другой обработки.

При наследовании необходимо сначала вызвать соответствующий метод `super.unbind()`.

**Сигнатура**

- `unbind()`

### `get()`

Получает значение параметра конфигурации поля.

**Сигнатура**

- `get(key: string): any`

**Параметры**

| Имя параметра | Тип      | Значение по умолчанию | Описание         |
| ------------- | --------- | ---------------------- | ---------------- |
| `key`         | `string`  | -                      | Название параметра |

**Пример**

```ts
const field = db.collection('users').getField('name');

// Получить значение параметра конфигурации имени поля, возвращает 'name'
console.log(field.get('name'));
```

### `merge()`

Объединяет значения параметров конфигурации поля.

**Сигнатура**

- `merge(options: { [key: string]: any }): void`

**Параметры**

| Имя параметра | Тип                     | Значение по умолчанию | Описание               |
| ------------- | ------------------------ | ---------------------- | ---------------------- |
| `options`     | `{ [key: string]: any }` | -                      | Объект с параметрами для объединения |

**Пример**

```ts
const field = db.collection('users').getField('name');

field.merge({
  // 添加一个索引配置
  index: true,
});
```

### `remove()`

Удаляет поле из таблицы данных (удаление происходит только из памяти).

**Пример**

```ts
const books = db.getCollections('books');

books.getField('isbn').remove();

// really remove from db
await books.sync();
```

## Методы базы данных

### `removeFromDb()`

Удаляет поле из базы данных.

**Сигнатура**

- `removeFromDb(options?: Transactionable): Promise<void>`

**Параметры**

| Имя параметра          | Тип           | Значение по умолчанию | Описание   |
| ---------------------- | ------------- | ---------------------- | ---------- |
| `options.transaction?` | `Transaction` | -                      | Экземпляр транзакции |

### `existsInDb()`

Определяет, существует ли поле в базе данных.

**Сигнатура**

- `existsInDb(options?: Transactionable): Promise<boolean>`

**Параметры**

| Имя параметра          | Тип           | Значение по умолчанию | Описание   |
| ---------------------- | ------------- | ---------------------- | ---------- |
| `options.transaction?` | `Transaction` | -                      | Экземпляр транзакции |

## Список встроенных типов полей

NocoBase содержит некоторые часто используемые типы полей, которые можно использовать при определении полей таблицы данных, указав соответствующее имя типа. Конфигурация параметров полей различается для разных типов; подробности можно найти в списке ниже.

Все параметры конфигурации типов полей, помимо дополнительно описанных ниже, передаются в Sequelize, поэтому здесь можно использовать все параметры полей, поддерживаемые Sequelize (например, `allowNull`, `defaultValue` и т.д.).

Кроме того, типы полей на стороне сервера в основном решают вопросы хранения в базе данных и некоторых алгоритмов и практически не связаны с типами отображения полей и компонентами, используемыми на фронтенде. Типы полей фронтенда можно найти в соответствующем разделе руководства.

### `'boolean'`

Логический тип.

**Пример**

```js
db.collection({
  name: 'books',
  fields: [
    {
      type: 'boolean',
      name: 'published',
    },
  ],
});
```

### `'integer'`

Целое число (32-битное).

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'integer',
      name: 'pages',
    },
  ],
});
```

### `'bigInt'`

Длинное целое число (64-битное).

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'bigInt',
      name: 'words',
    },
  ],
});
```

### `'double'`

Число с плавающей запятой двойной точности (64-битное).

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
  ],
});
```

### `'real'`

Тип действительных чисел (только для PostgreSQL).

### `'decimal'`

Тип десятичной дроби.

### `'string'`

Тип строковых данных. Эквивалентен типу `VARCHAR` в большинстве баз данных.

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
  ],
});
```

### `'text'`

Текстовый тип. Эквивалентен типу `TEXT` в большинстве баз данных.

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'text',
      name: 'content',
    },
  ],
});
```

### `'password'`

Тип пароля (расширение NocoBase). Основан на методе `scrypt` из встроенного пакета Node.js `crypto` для шифрования паролей.

**Пример**

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'password',
      name: 'password',
      length: 64, // 长度，默认 64
      randomBytesSize: 8, // 随机字节长度，默认 8
    },
  ],
});
```

**Параметры**

| Имя параметра      | Тип      | Значение по умолчанию | Описание           |
| ------------------ | -------- | ---------------------- | ------------------ |
| `length`           | `number` | 64                     | Длина символа      |
| `randomBytesSize`  | `number` | 8                      | Размер случайных байт |

### `'date'`

Тип даты.

### `'time'`

Тип времени.

### `'array'`

Тип массива (только для PostgreSQL).

### `'json'`

Тип JSON.

### `'jsonb'`

Тип JSONB (только для PostgreSQL, в других случаях будет преобразован в тип `'json'`).

### `'uuid'`

Тип UUID.

### `'uid'`

Тип UID (расширение NocoBase). Тип короткого случайного строкового идентификатора.

### `'formula'`

Тип формулы (расширение NocoBase). Позволяет настроить вычисления математических формул на основе [mathjs](https://www.npmjs.com/package/mathjs). В формуле можно использовать значения из других столбцов той же записи для расчетов.

**Пример**

```ts
db.collection({
  name: 'orders',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
    {
      type: 'integer',
      name: 'quantity',
    },
    {
      type: 'formula',
      name: 'total',
      expression: 'price * quantity',
    },
  ],
});
```

### `'radio'`

Тип радио (расширение NocoBase). Всей таблице может быть только одна строка, где значение этого поля равно `true`, остальные значения будут `false` или `null`.

**Пример**

В системе может быть только один пользователь, отмеченный как root. Когда для другого пользователя значение root изменяется на `true`, все остальные записи, где root было `true`, автоматически изменятся на `false`: 

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'radio',
      name: 'root',
    },
  ],
});
```

### `'sort'`

Тип сортировки (расширение NocoBase). Основан на целочисленных значениях для сортировки записей. Для новых записей автоматически генерируется новый порядковый номер, а при перемещении данных происходит переупорядочивание номеров.

Если в таблице данных определена опция `sortable`, соответствующее поле также будет создано автоматически.

**Пример**

Статьи могут быть отсортированы на основе принадлежности пользователю.
```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'user',
    },
    {
      type: 'sort',
      name: 'priority',
      scopeKey: 'userId', // 以 userId 相同值分组的数据进行排序
    },
  ],
});
```

### `'virtual'`

Виртуальный тип. Не хранит данные физически, используется только для определения специальных getter/setter.

### `'belongsTo'`

Тип связи "многие к одному". Внешний ключ хранится в текущей таблице, противоположность hasOne/hasMany.

**Пример**

Любая статья принадлежит определенному автору:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'author',
      target: 'users', // Если не настроено, по умолчанию используется имя в форме множественного числа от "name"
      foreignKey: 'authorId', // Если не настроено, по умолчанию используется формат <name> + Id
      sourceKey: 'id', // Если не настроено, по умолчанию используется id таблицы target
    },
  ],
});
```

### `'hasOne'`

Тип связи "один к одному". Внешний ключ хранится в связанной таблице, противоположность belongsTo.

**Пример**

У любого пользователя есть один личный профиль:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasOne',
      name: 'profile',
      target: 'profiles', // 可省略
    },
  ],
});
```

### `'hasMany'`

Тип связи "один ко многим". Внешний ключ хранится в связанной таблице, противоположность belongsTo.

**Пример**

У любого пользователя может быть несколько статей:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasMany',
      name: 'posts',
      foreignKey: 'authorId',
      sourceKey: 'id',
    },
  ],
});
```

### `'belongsToMany'`
Тип связи "многие ко многим". Используется промежуточная таблица для хранения внешних ключей обеих сторон. Если не указать существующую таблицу в качестве промежуточной, она будет создана автоматически.

**Пример**

К любой статье можно добавить произвольное количество тегов, и любой тег может быть добавлен к произвольному количеству статей:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsToMany',
      name: 'tags',
      target: 'tags', // При совпадении имени можно опустить.
      through: 'postsTags', // Если промежуточная таблица не настроена, она будет сгенерирована автоматически.
      foreignKey: 'postId', // Внешний ключ текущей таблицы в промежуточной таблице.
      sourceKey: 'id', // Первичный ключ текущей таблицы.
      otherKey: 'tagId', // Внешний ключ связанной таблицы в промежуточной таблице.
    },
  ],
});

db.collection({
  name: 'tags',
  fields: [
    {
      type: 'belongsToMany',
      name: 'posts',
      through: 'postsTags', // Одна и та же группа отношений указывает на одну и ту же промежуточную таблицу.
    },
  ],
});
```
